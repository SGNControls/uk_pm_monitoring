import time, json, ssl, math from datetime import datetime, timezone, timedelta import paho.mqtt.client as mqtt import serial, requests, smbus # ===== ADS1115 for NO2 + Noise ===== from ADS1115 import ADS1115 adc = ADS1115(address=0x48) adc.debug = False WE0 = 0.300 AE0 = 0.290 SENS = 0.40 CORR = 1.0 def read_no2_ppb(): WE_mv = adc.readADCSingleEnded(0) AE_mv = adc.readADCSingleEnded(1) WE = WE_mv / 1000.0 AE = AE_mv / 1000.0 ppb = (WE - WE0 - CORR*(AE - AE0)) / SENS return max(ppb, 0) def read_noise_db(duration=0.1): samples=[] start=time.time() while (time.time() - start) < duration: mv = adc.readADCSingleEnded(2) voltage = mv/1000.0 samples.append(voltage) mean = sum(samples)/len(samples) samples = [s-mean for s in samples] rms = math.sqrt(sum([s*s for s in samples]) / len(samples)) db = 20*math.log10(rms/0.00002) if rms>0 else 0 return round(db,2) # ===== MQTT CONFIG ===== DEVICE_ID = "1224" PUBLISH_INTERVAL = 10 # seconds MQTT_HOST = "461dec45331a4366882762ab7221c726.s1.eu.hivemq.cloud" MQTT_PORT = 8883 MQTT_USERNAME = "hivemq.webclient.1765452496255" MQTT_PASSWORD = "24csnE%<MLVSQ#6d9!zb"  # FIXED: Correct password MQTT_TOPIC = "sensor/data" # ===== TSI PM CONFIG ===== TSI_CLIENT_ID = 'rY4EE4WxXGgwtJHdgOXnnD3RDY9pk0Zwpb6DKwjmdBAtSGei' TSI_CLIENT_SECRET = 'SiQDcoYcWJYc0NzWAdMHgEXXwxr0dwvp1MJEAZhlc1hZvPdJUznBnBuALK17ZIHT' TSI_DEVICE_ID = 'd4uh73qmsnoc73dn1r30' TSI_BASE_URL = "https://api-prd.tsilink.com/api/v3/external" tsi_token = None tsi_expiry = None def tsi_get_access_token(): global tsi_token, tsi_expiry if tsi_token and tsi_expiry and datetime.utcnow() < tsi_expiry: return tsi_token url = f"{TSI_BASE_URL}/oauth/client_credential/accesstoken?grant_type=client_credentials" data = {"client_id": TSI_CLIENT_ID, "client_secret": TSI_CLIENT_SECRET} headers = {"Content-Type": "application/x-www-form-urlencoded"} resp = requests.post(url, data=data, headers=headers, timeout=10) resp.raise_for_status() tok = resp.json() tsi_token = tok["access_token"] exp = int(tok.get("expires_in", 3599)) tsi_expiry = datetime.utcnow() + timedelta(seconds=exp-60) return tsi_token def tsi_fetch_pm(): token = tsi_get_access_token() url = f"{TSI_BASE_URL}/telemetry/flat-format" headers = {"Authorization": f"Bearer {token}", "Accept": "application/json"} params = [ ("telem[]","mcpm1x0"), ("telem[]","mcpm2x5"), ("telem[]","mcpm4x0"), ("telem[]","mcpm10"), ("telem[]","tpsize"), ("device_id", TSI_DEVICE_ID), ("latest_as_of_date", datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ')), ] resp = requests.get(url, headers=headers, params=params, timeout=12) resp.raise_for_status() data = resp.json() if not data: return None d = data[0] return [ d.get("mcpm1x0"), d.get("mcpm2x5"), d.get("mcpm4x0"), d.get("mcpm10"), d.get("tpsize") ] # ===== SIM7080G GNSS ===== class SIM7080G_GNSS: def __init__(self, port="/dev/ttyS0", baud=115200, timeout=2): self.ser = serial.Serial(port, baudrate=baud, timeout=timeout) time.sleep(0.5) self.ser.reset_input_buffer() self.send_cmd("AT+CGNSPWR=1", 1.0) def send_cmd(self, cmd, delay=0.3): self.ser.reset_input_buffer() self.ser.write((cmd + "\r\n").encode()) time.sleep(delay) return self.ser.read_until(b"OK\r\n").decode(errors="ignore") def get(self): resp = self.send_cmd("AT+CGNSINF",0.5) if "+CGNSINF" not in resp: return None p = resp.split(",") if len(p) < 7: return None if p[1] != "1": return {"fix": False} return { "fix": True, "lat": float(p[3]), "lon": float(p[4]), "alt": float(p[5]), "spd": float(p[6]) * 3.6 } # ===== LOCAL SENSORS ===== bus = smbus.SMBus(1) import BME280, LTR390, TSL2591, SGP40 bme = BME280.BME280() bme.get_calib_param() uv = LTR390.LTR390() lux = TSL2591.TSL2591() sgp = SGP40.SGP40() # GNSS init gnss = SIM7080G_GNSS() last_gps = {"lat":None,"lon":None,"alt":None,"spd":None} # ===== MQTT INIT ===== mqtt_client = mqtt.Client() mqtt_client.username_pw_set(MQTT_USERNAME, MQTT_PASSWORD) mqtt_client.tls_set(cert_reqs=ssl.CERT_REQUIRED) mqtt_client.connect(MQTT_HOST, MQTT_PORT, 60) mqtt_client.loop_start() print("MQTT connected, publishing compact AQ data...") # ===== MAIN LOOP ===== while True: # --- ENV DATA (e[]) --- temp, hum, pres = bme.readData()[1], bme.readData()[2], bme.readData()[0] lux_val = lux.Lux() uv_raw = uv.UVS() uv_index = uv_raw / 2300.0 # UV = A voc = sgp.raw() # raw SGP40 reading (non-ppb scaled) no2 = read_no2_ppb() noise = read_noise_db() e = [ temp, # C hum, # % pres, # hPa uv_index, # UV index lux_val, # lux voc, # raw VOC no2, # NO2 ppb noise # dB ] # --- PM (pm[]) --- pm = tsi_fetch_pm() if not pm: pm = [None,None,None,None,None] # --- GPS (g{}) --- gps = gnss.get() if gps and gps["fix"]: g = {"lat":gps["lat"], "lon":gps["lon"], "alt":gps["alt"], "spd":gps["spd"]} else: g = last_gps if last_gps["lat"] else {"lat":None,"lon":None,"alt":None,"spd":None} payload = { "i": DEVICE_ID, "t": datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ"), "e": e, "pm": pm, "g": g } msg = json.dumps(payload, separators=(",",":")) mqtt_client.publish(MQTT_TOPIC, msg) print("ðŸ“¤ Published:", msg) time.sleep(PUBLISH_INTERVAL)
