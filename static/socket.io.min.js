// Enhanced Socket.IO Client Implementation
(function() {
    'use strict';

    window.io = function(url, options) {
        return new SocketIOClient(url, options);
    };

    function SocketIOClient(url, options) {
        this.url = url || window.location.origin;
        this.options = options || {};
        this.connected = false;
        this.reconnecting = false;
        this.eventListeners = {};
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 10;
        this.reconnectDelay = 1000;
        
        // Auto-connect if not specified otherwise
        if (this.options.autoConnect !== false) {
            this.connect();
        }
    }

    SocketIOClient.prototype.connect = function() {
        if (this.connected || this.reconnecting) return;
        
        try {
            // Use EventSource for basic real-time connection
            this.eventSource = new EventSource('/stream');
            
            this.eventSource.onopen = () => {
                this.connected = true;
                this.reconnecting = false;
                this.reconnectAttempts = 0;
                console.log('[Socket.IO] Connected via EventSource');
                this.emit('connect');
            };
            
            this.eventSource.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    this.emit(data.type || 'message', data.payload || data);
                } catch (e) {
                    console.warn('[Socket.IO] Failed to parse message:', event.data);
                }
            };
            
            this.eventSource.onerror = () => {
                this.connected = false;
                console.log('[Socket.IO] Connection lost, attempting to reconnect...');
                this.emit('disconnect');
                this.reconnect();
            };
            
        } catch (e) {
            console.warn('[Socket.IO] EventSource not available, using polling fallback');
            // Fallback to polling
            this.startPolling();
        }
    };

    SocketIOClient.prototype.startPolling = function() {
        this.connected = true;
        console.log('[Socket.IO] Connected via polling fallback');
        this.emit('connect');
        
        // Simple polling mechanism
        this.pollInterval = setInterval(() => {
            // This would normally fetch updates, but for now just maintain connection
            if (!this.connected) {
                clearInterval(this.pollInterval);
            }
        }, 5000);
    };

    SocketIOClient.prototype.reconnect = function() {
        if (this.reconnecting || this.reconnectAttempts >= this.maxReconnectAttempts) {
            return;
        }
        
        this.reconnecting = true;
        this.reconnectAttempts++;
        
        setTimeout(() => {
            console.log(`[Socket.IO] Reconnect attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);
            this.connect();
        }, this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1));
    };

    SocketIOClient.prototype.disconnect = function() {
        this.connected = false;
        this.reconnecting = false;
        
        if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = null;
        }
        
        if (this.pollInterval) {
            clearInterval(this.pollInterval);
            this.pollInterval = null;
        }
        
        console.log('[Socket.IO] Disconnected');
    };

    SocketIOClient.prototype.on = function(event, callback) {
        if (!this.eventListeners[event]) {
            this.eventListeners[event] = [];
        }
        this.eventListeners[event].push(callback);
    };

    SocketIOClient.prototype.emit = function(event, data) {
        // Emit to local listeners
        if (this.eventListeners[event]) {
            this.eventListeners[event].forEach(callback => {
                try {
                    callback(data);
                } catch (e) {
                    console.error('[Socket.IO] Error in event listener:', e);
                }
            });
        }
        
        // For actual server communication, use HTTP requests
        if (event === 'join' || event === 'leave') {
            this.sendToServer(event, data);
        }
    };

    SocketIOClient.prototype.sendToServer = function(event, data) {
        if (!this.connected) return;
        
        fetch('/api/socket/' + event, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        }).catch(e => {
            console.warn('[Socket.IO] Failed to send to server:', e);
        });
    };

    SocketIOClient.prototype.isConnected = function() {
        return this.connected;
    };

})();
